#' This function initializes the REvoBC object, by computing the set of Amplicon Sequence Variants.
#' It wraps all the steps performed by dada2, that are the following:
#' (1) Filter and trimming reads.
#' (2) Learning the error rates.
#' (3) Dereplication.
#' (4) Sample Inference.
#' (5) Merging forward and reverse reads.
#' (6) Construction of the Amplicon Sequence Variant table (ASV). 
#' (7) Removal of chimeras.
#' (8) [Optional] Production of a summary which tracks changes in the number of reads at every step of the pipeline.
#' 
#' For further information please refer to \href{https://benjjneb.github.io/dada2/tutorial_1_8.html}{the original vignette}.
#' If users wish to manually run each step of dada2 computation they should execute all steps reported
#' in the vignette, up to the Removal of chimeras and save the output of \code{removeBimeraDenovo} in a csv file and provide the path to that file as parameter \code{dada2_output_sequences}.
#' 
#' @title initialize_REvoBC
#' 
#' @examples
#' input_dir = system.file("exampleData", "input", package = "REvoBC")
#' output_dir = system.file("exampleData", "output", package = "REvoBC")
#' initialize_REvoBC(input_dir = input_dir, output_dir = output_dir)
#' 
#' @param input_dir. Path to the directory containing \code{.fastq} files for forward and reverse reads.
#' This folder should contain the fastq files (2 for each sample) with the following name pattern:
#' FILEPREFIX_SAMPLE_BARCODEVERSION_R1.fastq FILEPREFIX_SAMPLE_BARCODEVERSION_R1.fastq. SAMPLE refers to either an organ (in case multiple organs were sequenced)
#' or timepoint (if longitudinal data are provided). Note that REvoBC does not support mixed sample types (i.e. samples must be either all from organs or all from timepoints).
#' Required when \code{dada2_output_sequences} is null (i.e. when the user has not previously run dada2).
#' @param output_dir (Required). Path to the directory where all output files will be stored. The following \code{.csv} files will be created:
#' \itemize{
#' \item \code{quality_track_reads.csv}: track of the number of sequences during the 
#' different stepsof \code{dada2} analysis.
#' \item \code{01_seqtab_df.csv}: sequences detected by dada2, with the counts detected in each sample.
#' }
#' @param dada2_output_sequences (Optional). In case users have already run dada2 up to the removal of bimeras, they should provide the path to the csv file containing the output (See description).
#' The output should contain samples on rows and sequences on columns.
#' @param output_dir_dada2 (Optional). Output folder for dada2 filtered fastqs. If it doesn't exist it is created. Default is NULL and results in creating a 
#' sub-folder in \code{output_folder} named 'filtered_fastq/'.
#' @param random_seed (Optional). Seed for reproducibility. Deafult is NULL.
#' @param output_figures (Optional). Boolean indicating whether or not to save intermediate dada2 plots such as read quality profiles.
#' Deafult is \code{TRUE} and corresponds to creating a sub-folder inside \code{output_dir} named "dada2_plots".
#' This folder will contain the following plots:
#' \itemize{
#' \item Quality profiles of both forward and reverse reads (generated by \code{dada2}).
#' \item Error rates (generated by \code{dada2}).
#' \item Histogram of sequences length.
#' }
#' @param multithread (Optional) default \code{TRUE}. Whether to enable multithreading. If TRUE the number of threads is determined automatically (dada2 functionality).
#' If an integer is given, the number of threads is determined by its value.
#' @param map_file_sample (Optional). In case fastq files names are not in the format FILEPREFIX_SAMPLE_BARCODEVERSION_RX.fastq),
#' then users should provide a list that associates each filename (without the suffix _R1 and _R2) to the corresponding organ/day.
#' (e.g., if we have forward and reverse files named file1_R1.fastq and file1_R2.fastq that correspond to organ PRL (code for Prostate Left), than the parameter should be set as: \code{map_file_sample = c("file1" = "PRL")}).
#' @param dada2_pooled_analysis (Optional). Deafault = FALSE. Boolean that is passed to dada2 function \code{dada}, which performs sample inference.
#' It can be set to TRUE in case of multiple samples coming from the same mouse (e.g. different organs or multiple time points) (See \href{https://benjjneb.github.io/dada2/pool.html}{here} for more information).
#' @param dada2_chimeras_minFoldParentOverAbundance (Optional). Deafult = 8. parameter passed to the \code{dada2} function \code{isBimeraDenovo} during the call to \code{dada2 removeBimeraDenovo}. 
#' @param verbose (Optional). Default TRUE. Boolean indicating whether or not to print the text output of dada2 functions.
#' 
#' @return An object of type REvoBC, which is a list that will contain the following fields: 
#' \itemize{
#' \item \code{fastq_directory}: directory where the input fastq files are located.
#' \item \code{output_directory}: directory where all the output files are being stored.
#' \item \code{map_file_sample}: dataframe has as many rows as the input datasets, and for each input stores the sample (e.g. organ or day for longitudinal data)
#' to which it is associated.
#' \item \code{dada2_asv_prefilter}: dataframe that stores all sequences detected by \code{dada2}. Note that
#' these sequences still need to be filtered (@seealso \code{\link{asv_analysis}}).
#' \item \code{dada2}: list which contains the percentage of chimeras found by \code{dada2} and a dataframe
#' that tracks the number of sequences during all \code{dada2} steps.
#' }. This function also saves the following \code{.csv files} in the subfolder \code{dada2_files} created in the output dirctory provided by the user:
#' \itemize{
#' \item dada2_asv_prefilter.csv
#' \item quality_track_reads.csv: track of the number of sequences during all \code{dada2} steps.
#' }
#' 
#' 
#' @export initialize_REvoBC
#' 
#' @import dada2
#' @import ggplot2
#' @import dplyr
#' @importFrom cli cli_alert_info
#' 
initialize_REvoBC = function(input_dir = NULL,
                              output_dir,
                              dada2_output_sequences = NULL,
                              output_dir_dada2 = NULL,
                              random_seed = NULL,
                              output_figures = TRUE,
                              multithread = TRUE,
                              map_file_sample = NULL,
                              dada2_pooled_analysis = FALSE,
                              dada2_chimeras_minFoldParentOverAbundance = 8,
                              verbose = TRUE,
                              ...) {
  # Check that the user inserted the correct parameters
  if (is.null(input_dir) & is.null(dada2_output_sequences)) {
    stop('Please provide either a directory containing fastqs for dada2 or the path to dada2 output')
  }
  if (is.null(output_dir)) {
    stop('Please provide a path where output files will be stored.')
  }

  set.seed(random_seed)
  REvoBC_object = list(fastq_directory = input_dir, output_directory = output_dir)
  
  class(REvoBC_object) = 'REvoBC'
  REvoBC_object$dada2 = list()
  if (is.null(dada2_output_sequences)) {
    # Fastq were provided as input -> perform alignment with dada2
    fastqs = list.files(input_dir, pattern = '.fastq$')

    fastqs = sort(fastqs) 
    fnFs = fastqs[grepl("_R1", fastqs)] 
    fnRs = fastqs[grepl("_R2", fastqs)] 
    # Get sample names, assuming files named as so: SAMPLENAME_XXX.fastq
    sample.names = str_remove_all(fnFs, "_R1.fastq")
    map_file_sample = check_input(sample.names = sample.names, 
                                   map_file_sample = map_file_sample)
    # Specify the full path to the fnFs and fnRs
    fnFs = file.path(input_dir, fnFs)
    fnRs = file.path(input_dir, fnRs)
    
    output_dir_files = file.path(output_dir, "dada2_files")
    if (!dir.exists(output_dir_files)) dir.create(output_dir_files)
    
    align_output = dada2_alignment(fnFs = fnFs,
                                   fnRs = fnRs,
                                   map_file_sample = map_file_sample,
                                   sample.names = sample.names,
                                   output_dir = output_dir,
                                   output_dir_files = output_dir_files,
                                   output_dir_dada2 = output_dir_dada2,
                                   output_figures = output_figures,
                                   multithread = multithread,
                                   dada2_pooled_analysis = dada2_pooled_analysis,
                                   verbose =  T,
                                   dada2_minFoldParentOverAbundance = dada2_chimeras_minFoldParentOverAbundance,
                                   ...)
    
    seqtab.nochim = align_output$seqtab.nochim
    REvoBC_object$dada2$track = align_output$track
    REvoBC_object$dada2$bimera_percentage = align_output$bimera_perc
    REvoBC_object$dada2$original_sequences = align_output$nSequences_with_chimeras
    
  } else {
    seqtab.nochim = read.csv(dada2_output_sequences, 
                             stringsAsFactors = FALSE,
                             row.names = 1)
    map_file_sample = check_input(sample.names = rownames(seqtab.nochim), 
                                   map_file_sample = map_file_sample)
  }
  REvoBC_object$map_file_sample = map_file_sample
  REvoBC_object$dada2_asv_prefilter = adjust_seqtab(seqtab.nochim = seqtab.nochim,
                                                    map_file_sample = map_file_sample,
                                                    output_dir_files = output_dir_files)
  return(REvoBC_object)
  
}

#' This function performs the analysis on ASV sequences identified by dada2.
#' First, it removes possible contamination sequences (ASVs resulting from other barcodes). 
#' Then it performs pairwise alignment using Needleman-Wunsch global alignment algorithm implemented in function \code{pairwiseAlignment}
#' in package \code{Biostrings}, aligning each sequence to the original barcode considered in the analysis 
#' (See the Biostrings documentation \href{https://www.rdocumentation.org/packages/Biostrings/versions/2.40.2/topics/pairwiseAlignment}{here} for more details).
#' Then it considers all those sequences exhibiting a similarity higher than \code{pid_cutoff_nmbc} with the original barcode as Non-Marking Guide Controls.
#' Finally, it computes different statistics for the ASVS, storing:
#'  the relative frequency of all ASVs in each sample. 
#'  the relative frequency of each ASV in the samples.
#'  the counts for each ASV normalized to the counts of the sample with maximum frequency
#'  the frequency of the different ASVs in each sample.
#'  
#' @title ASV_analysis
#' 
#' @examples
#' data(revo_initialized)
#' revo_analyzed = asv_analysis(REvoBC_object = evo_obj, barcode = 'BC10v0.ORG')
#' 
#' @param REvoBC_object (Required). Object of class REvoBC, result of the function \code{initialize_REvoBC}
#' @param barcode (Required). String indicating the barcode used in the experiment.
#' @param output_figures (Optional). Deafult TRUE: Boolean indicating whether a user whishes to store a figure indicating the number of ASV tracked during the different steps of the analysis.
#' @param pid_cutoff_nmbc (Optional). Default to 98%. Percentage of similarity between a sequence and the original barcode. The ASVs with a similarity obve this threshold will be considered as original non-mutated sequences in the analysis.
#' @param export_statistics (Optional). Default = TRUE. Boolean indicating whether the user wishes to compute, for each ASV and each day/organ the frequency of counts.
#' @param asv_count_cutoff (Optional). Default to 2. Minimum number of counts for an ASV to be considered in the statistics.
#' @param ... Any additional parameters passed to \code{pairwiseAlignment} from \code{Biostrings} (See description).
#'
#' @return  The REvoBC object passed as a parameter with the following new fields:
#' \itemize{
#' \item \code{clean_asv_dataframe}: ASV sequences identified post-filtering (contamination removed,
#' sequences with a similarity higher than \code{pid_cutoff_nmbc} to the original barcode
#' aggregated to it and ASVs named in increasing order (ASV01, ASV02, etc.) according
#' to their total counts. 
#' \item \code{barcode}: Info about the barcode selected for the current analysis.
#'
#'  \item \code{statistics}: another list with the following sub-fileds: 
#' \itemize{
#' 
#' \item \code{asv_df_percentages}: dataframe with six columns. \code{asv_names} is the name of the ASV.
#' \code{day_organ} is the sample identifier (e.g. ID of an organ or, in case of longitudinal data, of the timepoint);
#' \code{count}: total counts for a specific ASV in a specific sample;
#' \code{perc_in_sample}: counts normalized to the total counts in the corresponding sample;
#' \code{perc_asv}: conuts normalized to the total counts for the corresponding ASV;
#' \code{perc_fold_to_max}: counts normalized to the maximum counts observed for the corresponding ASV in a sample.
#' 
#' \item \code{asv_totalCounts}: for each ASV, total counts and number of samples in which it was detected.
#' \item \code{sample_totalCounts}: for each sample, total counts and number of distinct ASVs detected.
#' \item \code{asv_diversity_perSample}: measures of clonal richness and measures of heterogeneity computed for each sample based on the ASVs detected.
#' \item \code{asv_persample_frequency}: counts for each ASV in each sample.
#' \item \code{asv_persample_detection}: binary matrix indicating whether a sequence has been detected in the corresponding sample.
#' \item \cpde{asv_toBarcode_similarity}: edit distance, percentage similarity and alignment score of each ASV compared to the original barcode.
#' 
#' }
#' }  
#' 
#' It saves the following \code{.csv} files in a sub-folder \code{asv_analysis} of the main output folder:
#' \itemize{
#' \item \code{sequences_barcode_mapping.csv}: dataframe that stores, for each sequence,
#' its counts in all samples. It also overwrites the sequence name (column seq_names) 
#' of those that exactly match any of the possible barcodes, using the barcode identifier. The sequences
#' that don't match the barcode in the current analysis may be due to contamination. 
#' \item \code{clean_asv_dataframe.csv}, \code{asv_totalCounts.csv}, \code{sample_totalCounts.csv}, \code{asv_df_percentages.csv}, \code{asv_diversity_perSample.csv}  
#' \code{asv_persample_frequency.csv}, \item \code{asv_persample_detection.csv}, \code{asv_diversity_perSample.csv} and \code{asv_toBarcode_similarity.csv}: content of the corresponding variables with the same name described above.
#' 
#' }
#'  
#' @export asv_analysis
#'
#' @importFrom Biostrings pairwiseAlignment pid nedit score
#' @importFrom benthos total_abundance species_richness margalef rygg simpson hpie hill1 hill2 shannon
#' @importFrom lemon coord_capped_cart facet_rep_grid
#' @importFrom scales comma
#' @import dplyr
#' @import ggplot2
#' 
asv_analysis = function(REvoBC_object,
                        barcode = 'BC10v0.ORG',
                        output_figures = TRUE,
                        pid_cutoff_nmbc = 98,
                        asv_count_cutoff = 2,
                        ...) {
  dots = list(...)
  if (output_figures) {
    figure_dir = file.path(output_dir, "asv_analysis_figures")
    if (!dir.exists(figure_dir)) dir.create(figure_dir)
  } else {
    figure_dir = NULL
  }
  output_dir = file.path(REvoBC_object$output_directory, "asv_analysis")
  if (!dir.exists(output_dir)) dir.create(output_dir)
  
  barcodes_info = data.frame(
    asv_names = c("BC10v0.ORG", "BC10v1.ORG", "BC10v2.ORG", "BC10v3.ORG", "BC10v4.ORG", "g.70.Rb1.ORG", "g.1348.Rb1.ORG"),
    seq_start = c("^TCTAC", "^TCTAC", "^TCTAC", "^TCTAC", "^TCTAC", "^TCTAC", "^TCTAC"), # 5x nts
    seq_end = c("CCCGTGGATC$", "GCCGGGGATC$", "ACCGGGGATC$", "ACCCTGGATC$", "GCCGCGGATC$", "GCATGACGCG$", "GTTTGTCCAT$"),
    seq = c("TCTACACGCGCGTTCAACCGAGGAAAACTACACACACGTTCAACCACGGTTTTTTACACACGCATTCAACCACGGACTGCTACACACGCACTCAACCGTGGATATTTACATACTCGTTCAACCGTGGATTGTTACACCCGCGTTCAACCAGGGTCAGATACACCCACGTTCAACCGTGGTACTATACTCGGGCATTCAACCGCGGCTTTCTGCACACGCCTACAACCGCGGAACTATACACGTGCATTCACCCGTGGATC",
            "TCTACACGCGCGTTCAACCGAGGAAAACTACACACACGTTCAACCACGGTTTGTTACACACGCATTCAACCGCGGACTATTACACGCTCGTTCAACCAGGGATATTTACACGCAAGTTCAACCACGGATTTATACACGCGCACTCAACCAGGGTCATCTACGCAAGCGTTCAATCGAGGTACATTCCACGCGCATTCAACCGGGGCTTTTTACACCCGCGCTCAACAGGGGAACTTTACACGTGCGATCAGCCGGGGATC",
            "TCTACACGCGCGTTCAACCGAGGAAAACTACACACGCATTCAACCACGGTTTATTACACGCACATTCAACCGTGGACTGCTACACACGCGCTCAACCACGGATATTTACGCACACGTTCAACCGCGGATTGTTACACCCGCATTCAACCGAGGTCACCTACACCCGCACTCAACCGGGGTACGCGACACGTGCGATCAACCGAGGCTTACTACCCGCACGTTCAACTGGGGAACACTGCACGCGAGTTCGACCGGGGATC",
            "TCTACACGCGCGTTCAACCGAGGAAAACTACACACACATTCAACCGTGGTTTACTACACAAGCGTTCAACCAAGGACTCCTACACATACGTTCAACCGTGGATATTTACACGTTCGTTCAACCAGGGATTTTTACAAACGAGTTCAACCGGGGTCACTTATACGCTCGTTCAACCGAGGTACTCTACACGCACCTTCAATCACGGCTTCCTACAGGAGCGTTCAAACGCGGAACTCAACGGGCGCGTTCAACCCTGGATC",
            "TCTACACGCGCGTTCAACCGAGGAAAACTACACACACATTCAACCGTGGTTTATTACACGCACGTTCAACCAGGGACTTTTACATACGCATTCAACCGGGGATATTTACTCACACGTTCAACCGGGGATTGCTACACGAACGTTCAATCGCGGTCATCAACGTGCGCATTCAACCGTGGTACACTACGCACCCGTTCAACCGGGGCTTTGGACACGCGCATACAACCGTGGAACTCTACACAGGCATTCAGCCGCGGATC",
            "GCTCCCTTCCCTTCCCTTCTCTCCGGCCCGCGGCGGCCGCGCTCCTCACCTGGCCAGGGGCAGCTCTTCGGGGCCGCTGTCCTGCGCGGGGTCGTCCTCCCGAGGCGGCGGCGGCGGCGGTGGCGGGGGCTCGGCGGCCGCGGCTCTGCGCGGGGCTTTGGGCGGCATGACGCG",
            "CTAGAAGGAGCAGAATGTGTTTCAATAAAAGACTTTAACAAAATTCAATTAACTTTTTGACTTTCTGAAACAGTAAAAGCTTATTATTTTTCCTTTTGTTTGTAGCGATATAAACTTGGAGTCCGATTGTATTACCGTGTGATGGAATCCATGCTTAAATCAGTAAGTTAAAGGAAACAAAATAGCAAAAAAATTTAATGCTGACACAAAGAAAGTTTCAATTAAAAGTTTTTTTTTCAATTATCTGTTTTAGGAAGAAGAACGTTTGTCCAT"),
    stringsAsFactors = FALSE)
  
  seqtab_df = REvoBC_object$dada2_asv_prefilter
  
  REvoBC_object$barcode = barcodes_info[barcodes_info$asv_names == barcode,]
  
  # Store the original numner of sequences and that after chimeras removal
  orgseq <- REvoBC_object$dada2$original_sequences
  chimseq_filter <- nrow(seqtab_df)
  sample = setdiff(colnames(seqtab_df), c("seq_names", "seq"))
  
  # Replace the seq-name for those sequences that match exactly one of the original barcodes.
  match_seq = match(seqtab_df$seq, barcodes_info$seq)
  barcodes_idx = match_seq[!is.na(match_seq)]
  seqtab_df$seq_names[!is.na(match_seq)] = gsub(pattern = '.ORG',replacement = '.NMBC', 
                                                x = barcodes_info$asv_names[barcodes_idx])
  seqtab_df_original = seqtab_df
  write.csv(seqtab_df, 
            file.path(output_dir,
                      "sequences_barcode_mapping.csv"),
            row.names = FALSE)
  
  # Removal of contamination: keep only those ASV that start (5 nucleotides) and end (10 nuceotides) like the original barcode.
  # The first 5 nts are the same for all barcodes, while the end is barcode-specific
  RD1_10 <- barcodes_info[barcodes_info$asv_names == barcode, 'seq_start']# as.character(dplyr::select(filter(bc_ver, asv_names == bc10_org), seq_start))
  RD2_10 <- barcodes_info[barcodes_info$asv_names == barcode, 'seq_end']
  nmbc <- gsub(pattern = 'ORG', replacement = 'NMBC', x=barcode)
  # filter based on 5' and 3' 10x nts of 
  seqtab_df <- dplyr::filter(seqtab_df, 
                             str_detect(string = seq, pattern = RD1_10) & str_detect(string = seq, pattern = RD2_10)) # the same for different barcodes: 1.0 - site less affected
  
  seqtab_df_original$condition = 'removed'
  seqtab_df_original[rownames(seqtab_df_original) %in% rownames(seqtab_df),]$condition = 'kept'
  seqtab_df_original$total_counts = rowSums(seqtab_df_original[,sample])
  
  seqtab_df_original$condition = as.factor(seqtab_df_original$condition)
  
  ggplot(seqtab_df_original[seqtab_df_original$seq_names != "BC10v0.NMBC",], 
         aes(x = total_counts, fill = condition)) +                       # Draw overlaying histogram
    geom_histogram(position = "identity", bins = 20, alpha=0.5) + scale_x_log10()
  
  
  endseq_filter <- nrow(seqtab_df)
  
  pwa <- do.call(Biostrings::pairwiseAlignment, 
                 c(list(subject = barcodes_info[barcodes_info$asv_names == barcode, 'seq'], 
                        pattern = seqtab_df$seq, 
                        type="global"),
                   get_args_from_dots(dots, Biostrings::pairwiseAlignment)))
  # Compute the percent sequence identity
  seqtab_df$pid <- Biostrings::pid(pwa)
  
  # Assign to each ASV with pid >= cutoff the original barcode and then pool the sequences
  # (the counts of each ASV with pid >= cutoff will be summed to the ones of the NMBC)
  pidseq_filter = seqtab_df %>% 
    mutate(seq_names = ifelse(pid >= pid_cutoff_nmbc, nmbc, seq_names)) %>%
    dplyr::select(seq_names, all_of(sample), pid) %>%
    group_by(seq_names) %>%
    dplyr::summarise_at(sample, sum) %>%
    merge(dplyr:: select(seqtab_df, seq_names, seq), by = "seq_names")
  pidseq_filter_dim = nrow(pidseq_filter)
  
  # Now sort ASV by total frequency and assign an ASV ID
  seqtab_df_clean_asv <-
    tibble(pidseq_filter) %>%
    mutate(asv_total_freq = rowSums(across(where(is.numeric)))) %>%
    arrange(-asv_total_freq)  %>%
    mutate(asv_names = seq_names)
  # Find Row for NMBC
  seqtab_df_clean_nmbc <- seqtab_df_clean_asv[str_detect(string = seqtab_df_clean_asv$seq_names, 
                                                         pattern = "NMBC"),]
  
  # skip NMBC
  seqtab_df_clean_asv <-
    seqtab_df_clean_asv %>%
    filter(!str_detect(string = seq_names, pattern = "NMBC")) 
  # create ASV count
  seqtab_df_clean_asv$asv_names <- paste0("ASV", 
                                          formatC(c(1:nrow(seqtab_df_clean_asv)), 
                                                  width = nchar(trunc(nrow(seqtab_df_clean_asv))), 
                                                  format = "d", flag = "0")) # -1 to start 00 with no changes sequence
  # add back row with "seqtab_df_perf_match"  
  seqtab_df_clean_asv <-
    seqtab_df_clean_asv %>%
    add_row(seqtab_df_clean_nmbc) %>%
    arrange(-asv_total_freq) %>%
    dplyr::select(-c(seq_names, asv_total_freq)) %>%
    relocate(asv_names)
  
  clean_asv <- nrow(seqtab_df_clean_asv)
  
  write.csv(seqtab_df_clean_asv, 
            file.path(output_dir, "/clean_asv_dataframe.csv"),
            row.names = F)
  
  REvoBC_object$clean_asv_dataframe = seqtab_df_clean_asv
  REvoBC_object = asv_statistics(REvoBC_object, 
                                 sample, 
                                 asv_count_cutoff,
                                 figure_dir,
                                output_dir = output_dir)

  if (output_figures) {
    seqtab_df_clean_track <-
      ggplot(data=data.frame(name=c("01_orgseq", "02_chimseq_filter", "03_endseq_filter", "04_pidseq_filter", "05_clean_asv"),
                             num=c(orgseq, chimseq_filter, endseq_filter, pidseq_filter_dim, clean_asv))) +
      geom_bar(aes(x=name, y=num), position = "dodge", stat = "identity", width=0.8, size=0.2) +
      geom_text(aes(x=name, y=num, label=num), check_overlap = TRUE, vjust=-0.25, size=3) + # change order to have up whatever you choose, opposte to order
      barplot_nowaklab_theme() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
    # save pdf
    ggsave(filename=file.path(figure_dir, "track_asv_number.pdf"), 
           plot=seqtab_df_clean_track, device=cairo_pdf, width=10, height=10, units = "cm")
  }
  
  return(REvoBC_object)
  
}

#' This function performs multi-sequence alignment and outputs statistics about mutations. 
#' Multiple Sequence Alignment is performed through the \href{https://bioconductor.org/packages/release/bioc/html/muscle.html}{MUSCLE} algorithm.
#' 
#' @title perform_msa
#' 
#' @examples 
#' data(revo_analysed)
#' revo_msa = perform_msa(revo_analyzed)
#' 
#' @param REvoBC_object REvoBC object on which we want to perform msa.
#' @param ... Optional parameters (options and flags) passed to MUSCLE. See the \href{http://www.drive5.com/muscle/muscle_userguide3.8.html}{original guide} for detailed information on all possible options.
#' 
#' @return REvoBC object with a new field named \code{alignment}, which is a list with the following fileds:
#' \itemize{
#' \item \code{msa_stringset}: output of MSA peformed with MUSCLE.
#' \item \code{mutations_df}: tibble where each line corresponds to a position in a ASV, and the columns encode the following information:
#' \itemize{
#' \item asv_names: name of the ASV
#' \item day_organ: sample
#' \item position_bc260: position of the alteration in the original barcode. Note that insertions
#' are assigned to the position that coincides with their beginning.
#' \item alt: type of alteration. wt = Wild Type (i.e. non-mutated position). sub = substitution. del = deletion. ins = insertion.
#' \item perc_in_sample: out of all sequences that map to a sample, the percentage of them that display the alteration.
#' }
#' }. 
#' In addition, the following files are saved in the sub-folder "msa" created inthe output directory chosen by the user:
#' \itemize{
#' \item dnastringset.fa: fasta file where the sequences are stored.
#' \item dnastringset.fa: same as fasta, but in csv format.
#' \item dnastringset_muscle-muscle_msa.fasta: fasta with the stringset resulted from MUSCLE.
#' \item ASV_alterationType_frequency.csv: number of alterations for each type in each ASV
#' \item mutations_frequency.csv: per sample normalized frequency of each alteration type, computed for each position of the barcode in each sample.
#' \item mutations_df.csv: content of mutations_df variable explained above.
#' }
#' 
#' 
#' @export perform_msa
#' @import dplyr
#' @import ggplot2
#' @importFrom muscle muscle
#' @importFrom Biostrings DNAStringSet writeXStringSet DNAMultipleAlignment
#' @importFrom  ggmsa tidy_msa 
#' @importFrom lemon coord_capped_cart facet_rep_grid
perform_msa = function(REvoBC_object, seed = NULL, ...) {
  dots = list(...)
  output_dir = file.path(REvoBC_object$output_directory, "msa")
  if(!dir.exists(output_dir)) dir.create(output_dir)
  df_to_plot_org_tree <- 
    dplyr::select(REvoBC_object$clean_asv_dataframe, asv_names, seq) %>%
    mutate_at("asv_names", str_replace, ".NMBC", ".ORG") %>%
    arrange(asv_names)
  
  
  ### Create Biostring and FASTA Files Data
  
  dnastringset <- Biostrings::DNAStringSet(df_to_plot_org_tree$seq) 
  names(dnastringset) <- df_to_plot_org_tree$asv_names
  
  # Output as FASTA files
  outputFileFASTA <- file.path(output_dir, "dnastringset.fa")
  Biostrings::writeXStringSet(dnastringset, outputFileFASTA)
  
  write.csv(dnastringset, file.path(output_dir, "dnastringset.csv"), col.names = FALSE, quote=FALSE)
  
  # Perform Multiple Sequence Alignment with muscle
  set.seed(seed)
  dnastringset_msa <- do.call(muscle::muscle, c(list(stringset = dnastringset),
                                                   get_args_from_dots(dots, muscle::muscle))) # suggestion: gapopen = -400
  Biostrings::writeXStringSet(as(dnastringset_msa, "DNAStringSet"), 
                  file.path(output_dir, "dnastringset_muscle-muscle_msa.fasta"))
  
  # Store MSA result
  msa = Biostrings::DNAMultipleAlignment(dnastringset_msa)
  REvoBC_object$alignment$msa_stringset = msa
  
  # Transform Alignment to "Tidy Data"
  alignment_tidy <- ggmsa::tidy_msa(msa=msa, 
                             start = 1, 
                             end = ncol(msa))
  
  REvoBC_object = count_alterations(REvoBC_object, alignment_tidy, output_dir)
  
  return(REvoBC_object)
  
}
