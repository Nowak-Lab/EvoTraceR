<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ASV_analysis — asv_analysis • EvoTraceR</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="ASV_analysis — asv_analysis"><meta name="description" content="This function performs the analysis on ASV sequences identified by the previous steps and aligns them to the reference sequence.
First, it pools together those sequences characterized by a Hamming distance equals or lower than 2, summing their counts. To perform this step, EvoTraceR uses the
sequence clusering agorithm impemented in the python package UMI-tools
Then it performs pairwise alignment using Needleman-Wunsch global alignment algorithm implemented in function pairwiseAlignment
in package pwalign, aligning each sequence to the original barcode considered in the analysis.
(See the pwalign documentation here for more details).
After identifying all indels (insertions are identified by their start position and number of nucleoides inserted, while deletions are identified by their start and end position),
it removes the ones that are too small and don't span any cut site: to perform this filter, it exapnds the start and end position by the number of bases specified in the parameter cleaning_window,
it counts the number of cut sites spanned after the expantion and it removes those that span 0 sites.
Next, it pools together those sequences that differ by one another only by substitutions.
Then it computes the normalized counts of each ASV in each sample, dividing each count by the total number of sequences for each sample and multiplying by 1e6, yelding Counts Per Million (CPM).
After normalization, counts are summed in each ASV, and those sequences showing a frequency lower than the threshold specified in parameter asv_count_cutoff are removed.
Finally, it performs filtering of the sequences based on their flanking sequences."><meta property="og:description" content="This function performs the analysis on ASV sequences identified by the previous steps and aligns them to the reference sequence.
First, it pools together those sequences characterized by a Hamming distance equals or lower than 2, summing their counts. To perform this step, EvoTraceR uses the
sequence clusering agorithm impemented in the python package UMI-tools
Then it performs pairwise alignment using Needleman-Wunsch global alignment algorithm implemented in function pairwiseAlignment
in package pwalign, aligning each sequence to the original barcode considered in the analysis.
(See the pwalign documentation here for more details).
After identifying all indels (insertions are identified by their start position and number of nucleoides inserted, while deletions are identified by their start and end position),
it removes the ones that are too small and don't span any cut site: to perform this filter, it exapnds the start and end position by the number of bases specified in the parameter cleaning_window,
it counts the number of cut sites spanned after the expantion and it removes those that span 0 sites.
Next, it pools together those sequences that differ by one another only by substitutions.
Then it computes the normalized counts of each ASV in each sample, dividing each count by the total number of sequences for each sample and multiplying by 1e6, yelding Counts Per Million (CPM).
After normalization, counts are summed in each ASV, and those sequences showing a frequency lower than the threshold specified in parameter asv_count_cutoff are removed.
Finally, it performs filtering of the sequences based on their flanking sequences."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">EvoTraceR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.4</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/1_introduction.html">Introduction</a></li>
    <li><a class="dropdown-item" href="../articles/2_running_REvoBC.html">Running EvoTraceR</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/Nowak-Lab/EvoTraceR/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>ASV_analysis</h1>
      <small class="dont-index">Source: <a href="https://github.com/Nowak-Lab/EvoTraceR/blob/master/R/user_functions.R" class="external-link"><code>R/user_functions.R</code></a></small>
      <div class="d-none name"><code>asv_analysis.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>This function performs the analysis on ASV sequences identified by the previous steps and aligns them to the reference sequence.
First, it pools together those sequences characterized by a Hamming distance equals or lower than 2, summing their counts. To perform this step, EvoTraceR uses the
sequence clusering agorithm impemented in the python package <a href="https://umi-tools.readthedocs.io/en/latest/QUICK_START.html" class="external-link">UMI-tools</a>
Then it performs pairwise alignment using Needleman-Wunsch global alignment algorithm implemented in function <code>pairwiseAlignment</code>
in package <code>pwalign</code>, aligning each sequence to the original barcode considered in the analysis.
(See the pwalign documentation <a href="https://bioconductor.org/packages/release/bioc/html/pwalign.html" class="external-link">here</a> for more details).
After identifying all indels (insertions are identified by their start position and number of nucleoides inserted, while deletions are identified by their start and end position),
it removes the ones that are too small and don't span any cut site: to perform this filter, it exapnds the start and end position by the number of bases specified in the parameter <code>cleaning_window</code>,
it counts the number of cut sites spanned after the expantion and it removes those that span 0 sites.
Next, it pools together those sequences that differ by one another only by substitutions.
Then it computes the normalized counts of each ASV in each sample, dividing each count by the total number of sequences for each sample and multiplying by 1e6, yelding Counts Per Million (CPM).
After normalization, counts are summed in each ASV, and those sequences showing a frequency lower than the threshold specified in parameter <code>asv_count_cutoff</code> are removed.
Finally, it performs filtering of the sequences based on their flanking sequences.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">asv_analysis</span><span class="op">(</span></span>
<span>  <span class="va">EvoTraceR_object</span>,</span>
<span>  ref_name <span class="op">=</span> <span class="st">"BC10v0"</span>,</span>
<span>  ref_seq <span class="op">=</span></span>
<span>    <span class="st">"TCTACACGCGCGTTCAACCGAGGAAAACTACACACACGTTCAACCACGGTTTTTTACACACGCATTCAACCACGGACTGCTACACACGCACTCAACCGTGGATATTTACATACTCGTTCAACCGTGGATTGTTACACCCGCGTTCAACCAGGGTCAGATACACCCACGTTCAACCGTGGTACTATACTCGGGCATTCAACCGCGGCTTTCTGCACACGCCTACAACCGCGGAACTATACACGTGCATTCACCCGTGGATC"</span>,</span>
<span>  ref_flank_left <span class="op">=</span> <span class="st">"^TCTAC"</span>,</span>
<span>  ref_flank_right <span class="op">=</span> <span class="st">"CCCGTGGATC$"</span>,</span>
<span>  flanking_filtering <span class="op">=</span> <span class="st">"right"</span>,</span>
<span>  ref_cut_sites <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">17</span>, <span class="fl">43</span>, <span class="fl">69</span>, <span class="fl">95</span>, <span class="fl">121</span>, <span class="fl">147</span>, <span class="fl">173</span>, <span class="fl">199</span>, <span class="fl">225</span>, <span class="fl">251</span><span class="op">)</span>,</span>
<span>  ref_border_sites <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">26</span>, <span class="fl">52</span>, <span class="fl">78</span>, <span class="fl">104</span>, <span class="fl">130</span>, <span class="fl">156</span>, <span class="fl">182</span>, <span class="fl">208</span>, <span class="fl">234</span><span class="op">)</span>,</span>
<span>  output_figures <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  asv_count_cutoff <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  pwa_gapOpening <span class="op">=</span> <span class="op">-</span><span class="fl">25</span>,</span>
<span>  pwa_gapExtension <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  pwa_match <span class="op">=</span> <span class="fl">15</span>,</span>
<span>  pwa_mismatch <span class="op">=</span> <span class="op">-</span><span class="fl">4</span>,</span>
<span>  pwa_type <span class="op">=</span> <span class="st">"global"</span>,</span>
<span>  cleaning_window <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">3</span><span class="op">)</span>,</span>
<span>  batch_size <span class="op">=</span> <span class="fl">100</span>,</span>
<span>  cores <span class="op">=</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/detectCores.html" class="external-link">detectCores</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-evotracer-object">EvoTraceR_object<a class="anchor" aria-label="anchor" href="#arg-evotracer-object"></a></dt>
<dd><p>(Required). Object of class EvoTraceR, result of the function <code>initialize_EvoTraceR</code></p></dd>


<dt id="arg-ref-name">ref_name<a class="anchor" aria-label="anchor" href="#arg-ref-name"></a></dt>
<dd><p>String indicating the ID of the reference sequence used in the experiment. Default is 'BC10v0',</p></dd>


<dt id="arg-ref-seq">ref_seq<a class="anchor" aria-label="anchor" href="#arg-ref-seq"></a></dt>
<dd><p>String indicating the reference sequence used in the experimenti. Default is 'TCTACACGCGCGTTCAACCGAGGAAAACTACACACACGTTCAACCACGGTTTTTTACACACGCATTCAACCACGGACTGCTACACACGCACTCAACCGTGGATATTTACATACTCGTTCAACCGTGGATTGTTACACCCGCGTTCAACCAGGGTCAGATACACCCACGTTCAACCGTGGTACTATACTCGGGCATTCAACCGCGGCTTTCTGCACACGCCTACAACCGCGGAACTATACACGTGCATTCACCCGTGGATC',</p></dd>


<dt id="arg-ref-flank-left">ref_flank_left<a class="anchor" aria-label="anchor" href="#arg-ref-flank-left"></a></dt>
<dd><p>String indicating the first nucleotides of the reference sequence that never mutate over the
course of the experiment. Default is "^TCTAC",</p></dd>


<dt id="arg-ref-flank-right">ref_flank_right<a class="anchor" aria-label="anchor" href="#arg-ref-flank-right"></a></dt>
<dd><p>String indicating the first nucleotides of the reference sequence that never mutate over the
course of the experiment. Default is "CCCGTGGATC$",</p></dd>


<dt id="arg-flanking-filtering">flanking_filtering<a class="anchor" aria-label="anchor" href="#arg-flanking-filtering"></a></dt>
<dd><p>Which among the flaning regions to use to filter out contaminated sequences.
Must be one of c('left', 'right', 'both', 'either'), default is 'both'</p></dd>


<dt id="arg-ref-cut-sites">ref_cut_sites<a class="anchor" aria-label="anchor" href="#arg-ref-cut-sites"></a></dt>
<dd><p>Positions in the reference sequence of the cutting sites. Default is c(17, 42, 68, 94, 120, 146, 171, 198, 224, 251),</p></dd>


<dt id="arg-ref-border-sites">ref_border_sites<a class="anchor" aria-label="anchor" href="#arg-ref-border-sites"></a></dt>
<dd><p>c(26, 52, 78, 104, 130, 156, 182, 208, 234).</p></dd>


<dt id="arg-output-figures">output_figures<a class="anchor" aria-label="anchor" href="#arg-output-figures"></a></dt>
<dd><p>(Optional). Default TRUE: Boolean indicating whether a user whishes to store a figure indicating the number of ASV tracked during the different steps of the analysis.</p></dd>


<dt id="arg-asv-count-cutoff">asv_count_cutoff<a class="anchor" aria-label="anchor" href="#arg-asv-count-cutoff"></a></dt>
<dd><p>(Optional). Default to 2. Minimum number of counts in Counts Per Million (CPM) for an ASV to be considered in the statistics.</p></dd>


<dt id="arg-pwa-gapopening">pwa_gapOpening<a class="anchor" aria-label="anchor" href="#arg-pwa-gapopening"></a></dt>
<dd><p>(Optional). Default is -25. Parameter <code>gapOpening</code> passed to <code>pairwiseAlignment</code> from <code>pwalign</code> (See description).</p></dd>


<dt id="arg-pwa-gapextension">pwa_gapExtension<a class="anchor" aria-label="anchor" href="#arg-pwa-gapextension"></a></dt>
<dd><p>(Optional). Default is 0. Parameter <code>gapExtension</code> passed to <code>pairwiseAlignment</code> from <code>pwalign</code> (See description). Default is 0.</p></dd>


<dt id="arg-pwa-match">pwa_match<a class="anchor" aria-label="anchor" href="#arg-pwa-match"></a></dt>
<dd><p>(Optional). Default is 15. Parameter indicating the score for matches during pairwise alignment with <code>pwalign</code>. This parameter,
together with the previous one, are used to construct the substitution matrix used by the function <code>pairwiseAlignment</code>.</p></dd>


<dt id="arg-pwa-mismatch">pwa_mismatch<a class="anchor" aria-label="anchor" href="#arg-pwa-mismatch"></a></dt>
<dd><p>(Optional). Default is -4. Parameter indicating the penalty for mismatch events during pairwise alignment with <code>pwalign</code>.</p></dd>


<dt id="arg-pwa-type">pwa_type<a class="anchor" aria-label="anchor" href="#arg-pwa-type"></a></dt>
<dd><p>(Optional). Parameter indicating the type of pairwise alignment. Must be one of One of "global", "local", "overlap", "global-local", and "local-global".
For more details see <a href="https://bioconductor.org/packages/release/bioc/html/pwalign.html" class="external-link">original documentation</a></p></dd>


<dt id="arg-cleaning-window">cleaning_window<a class="anchor" aria-label="anchor" href="#arg-cleaning-window"></a></dt>
<dd><p>(Optional). Default is c(3,3). Vector containing the number of nucleotides that we use for extending respectively the start and end position of each indel to determine the ones that don't span any cut sites and thus get removed. (See description for more information).</p></dd>


<dt id="arg-batch-size">batch_size<a class="anchor" aria-label="anchor" href="#arg-batch-size"></a></dt>
<dd><p>(Optional). Default is 100. Number of batches to split reads into for parallel execution of <code>pairwiseAlignment</code>. This parameter can be tuned together with the cores parameter to optimize the speed of alignment.</p></dd>


<dt id="arg-cores">cores<a class="anchor" aria-label="anchor" href="#arg-cores"></a></dt>
<dd><p>(Optional). Default is parallel::detectCores(). Number of cores to use for pairwise alignment.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>The EvoTraceR object passed as a parameter with the following new fields:</p><ul><li><p><code>clean_asv_dataframe</code>: ASV sequences identified post-filtering (contamination removed,
sequences with a similarity higher than <code>pid_cutoff_nmbc</code> to the original barcode
aggregated to it and ASVs named in increasing order (ASV01, ASV02, etc.) according
to their total counts.</p></li>
<li><p><code>reference</code>: Info about the reference sequence used for the current analysis.</p></li>
<li><p><code>statistics</code>: another list with the following sub-fields:</p><ul><li><p><code>asv_df_percentages</code>: dataframe with six columns. <code>asv_names</code> is the name of the ASV.
<code>sample</code> is the sample identifier (e.g. ID of an organ or, in case of longitudinal data, of the timepoint);
<code>count</code>: total counts per million for a specific ASV in a specific sample;
<code>perc_in_sample</code>: CPM normalized to the total counts in the corresponding sample;
<code>perc_asv</code>: CPM normalized to the total counts for the corresponding ASV;
<code>perc_fold_to_max</code>: CPM normalized to the maximum counts observed for the corresponding ASV in a sample.</p></li>
<li><p><code>asv_totalCounts</code>: for each ASV, total counts and number of samples in which it was detected.</p></li>
<li><p><code>sample_totalcounts</code>: for each sample, total counts and number of distinct ASVs detected.</p></li>
<li><p><code>asv_diversity_persample</code>: measures of clonal richness and measures of heterogeneity computed for each sample based on the ASVs detected.</p></li>
<li><p><code>asv_persample_frequency</code>: counts for each ASV in each sample.</p></li>
<li><p><code>asv_persample_detection</code>: binary matrix indicating whether a sequence has been detected in the corresponding sample.</p></li>
<li><p><code>asv_toBarcode_similarity</code>: edit distance, percentage similarity and alignment score of each ASV compared to the original barcode.</p></li>
<li><p><code>all_asv_statistics</code>: all the statistics computed on each ASV grouped together in the same tibble.</p></li>
</ul></li>
<li><p><code>alignment</code>, another list with the following fields:</p><ul><li><p><code>Binary_mutation_matrix</code>: binary matrix encoding the presence/absence of a mutation in an ASV.</p></li>
<li><p><code>asv_barcode_alignment</code>: tibble where each line corresponds to a position in a ASV, and the columns encode the following information:</p><ul><li><p>asv_names: name of the ASV</p></li>
<li><p>sample: sample identifier</p></li>
<li><p>position_bc260: position of the alteration in the original barcode. Note that insertions
are assigned to the position that coincides with their beginning.</p></li>
<li><p>alt: type of alteration. wt = Wild Type (i.e. non-mutated position). sub = substitution. del = deletion. ins = insertion.</p></li>
<li><p>ref_asv,</p></li>
<li><p>read_asv: respectively, the reference nucleotide observed in the original barcode and the one observed on the sequence.</p></li>
</ul></li>
<li><p><code>mutations_coordinates</code>: dataframe containing a list of all mutations, with their start and end position.</p></li>
<li><p><code>ASV_alterations_width</code>: dataframe containing the number of nucleotides affected by each type of mutation in each ASV.</p></li>
</ul></li>
</ul><p>This function saves the figure <code>asv_filtering_freq.pdf</code>, which is a barplot indicating the change in the number of sequences
during all the processing steps.</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>Then, using the CPM it computes different statistics for the final ASVS, storing:
 the relative frequency of all ASVs in each sample.
 the relative frequency of each ASV in the samples.
 the counts for each ASV normalized to the counts of the sample with maximum frequency.
 the frequency of the different ASVs in each sample.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span> <span class="co"># \dontrun{</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">EvoTraceR_object</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">EvoTraceR_object</span> <span class="op">=</span> <span class="fu">asv_analysis</span><span class="op">(</span>EvoTraceR_object <span class="op">=</span> <span class="va">EvoTraceR_object</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span> <span class="co"># }</span></span></span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Lucrezia Patruno, Daniele Ramazzotti, Armin Scheben, Stephen Staklinski, Rebecca Hassett, Dylan Riffle, Dawid Nowak.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.9000.</p>
</div>

    </footer></div>





  </body></html>

