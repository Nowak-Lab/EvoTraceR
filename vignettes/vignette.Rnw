%\VignetteEngine{knitr::knitr}

\documentclass[a4paper,9pt]{article}

<<style-knitr, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@

%\VignetteIndexEntry{REvoBC}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{url}
\usepackage{tcolorbox}
\usepackage{authblk}
\usepackage{underscore}

\begin{document}

\title{REvoBC: Analysis of Amplicon Sequence Variants after performing an experiment through the EVoBC kit}

\author[1]{Lucrezia Patruno}
\author[2]{Daniele Ramazzottii}
\author[2,3]{Dawid Nowak}

\affil[1]{Dept. of Informatics, Systems and Communication, Univ. of Milan-Bicocca, Milan, Italy.}
\affil[2]{School of Medicine and Surgery, Univ. of Milan-Bicocca, Monza, Italy.}
\affil[3]{Sandra and Edward Meyer Cancer Center, Weill Cornell Medicine, New York, USA.}

\date{\today}
\maketitle

\begin{tcolorbox}{\bf Overview.} 
REvoBC is the computational tool inside the project EboBC. After performing EvoBC experiments in the lab, this tool can be exploited to perform the analysis of Amplicon Sequence Variants.
It uses the algorithm dada2 to identify all ASVs, then performs multi-sequence alignment to identify mutations and finally performs the phylogeny reconstruction.

\vspace{1.0cm}

{\em In this vignette, we present the usage of REvoBC.}

\vspace{1.0cm}

\renewcommand{\arraystretch}{1.5}

\end{tcolorbox}

<<include=FALSE>>=
library(knitr)
opts_chunk$set(
concordance = TRUE,
background = "#f3f3ff",
dev = "cairo_pdf"
)
@

\newpage

\tableofcontents

\section{Using the REvoBC R package}

In order to perform the analysis, there are multiple functions that perform the different steps of the analysis pipeline. 
The first step initializes the REvoBC object, which is a list that gets populated step-by-step with multiple fields containing the result of the analysis.

<<req>>=
library("REvoBC")
@

The initialization function computes the set of Amplicon Sequence Variants, by wrapping all the steps performed by dada2, that are the following:
(1) Filter and trimming reads.
(2) Learning the error rates.
(3) Dereplication.
(4) Sample Inference.
(5) Merging forward and reverse reads.
(6) Construction of the Amplicon Sequence Variant table (ASV). 
(7) Removal of chimeras.
(8) Production of a summary which tracks changes in the number of reads at every step of the pipeline.


The main parameters for the initialization are the directory where the output will be stored and one of the following:
input directory: in this case users have the fastq files and want to perform the whole analysis using REvoBC. In this case they need to provide the path to the folder containing the fastq (which may be compressed), and then they can provide any additional parameter for dada2 functions.
dada2_output_sequences: in case users wish to manually run dada2 steps up to the removal of bimeras, they should provide the path to the csv file containing the output. The output should contain samples on rows and sequences on columns.

Important: each fastq file pair (forward and reverse) must be associated to the sample on which the experiment was performed. The sample can be either the organ of the moouse or the an ID for the timepoint in case longitudinal data is provided.
In order for REvoBC to associate each fastq pair to its sample users have two options:
one is to name the fastq following this pattern: FILEPREFIX_SAMPLE_FILESUFFIX_RX.fastq, where FILEPREFIX and FILESUFFIX can be any string (without the "_" character). In this case REvoBC will consider as sample ID the second field separated by the underscore.
The second option is to provide a list that associates each filename (without the suffix _R1 and _R2) to the corresponding sample. For example, if we have forward and reverse files named file1_R1.fastq and file1_R2.fastq that correspond to organ PRL (code for Prostate Left), than the parameter should be set as: map_file_sample = c("file1" = "PRL")).

In this example we will work with fastq files named according to the pattern, providing their directory as input.
<<example_input_parameters>>=
input_dir = system.file("extdata", "input", package = "REvoBC")
output_dir = system.file("extdata", "output", package = "REvoBC")
@

We can now perform the initialization. 

<<example_initialization>>=
revo_initialized = initialize_REvoBC(input_dir = input_dir, 
                                     output_dir = output_dir)
names(revo_initialized)
@

During the above computation, dada2 was run and all ASVs are detected. The result is an object of class REvoBC, which is populated by 5 fields: dada2 is a list which contains the percentage of chimeras found by dada2 and a dataframe
that tracks the number of sequences during all dada2 steps. map_file_sample is a dataframe with as many rows as the number of input datasets, and for each input stores the sample (e.g. organ or day for longitudinal data) to which it is associated.
dada2_asv_prefilter: dataframe that stores all sequences detected by dada2.

Next, we can perform the analysis of the ASV sequences identified by dada2. 
The next function finds those that map to the original barcodes and gives them the name of NMBC (Non-Marked BarCode), considering also those with a similarity higher than 98\% (parameter pid_cutoff_nmbc) with the original barcode as NMBC.
It also removes possible contamination artifacts (ASV that map to other barcodes used in earlier experiments).
Then, it normalises the observed counts of each ASV in each sample, both by the total counts in each organ and by the total count of each ASV.
It also computes additional  measures of clonal richness and measures of heterogeneity for each sample based on the ASVs detected. 

<<example_analysis>>=
revo_analyzed = asv_analysis(REvoBC_object = revo_initialized, barcode = 'BC10v0')
names(revo_analyzed)
@

There are three new fields: clean_asv_dataframe which contains the counts detected for each ASV after filtering (i.e. after filtering for contamination identification of NMBC).
barcode is the barcode considered for the analysis.
statistics: is a new list that contains all the results of the computation (see the manual for a detailed explanation). Among its fileds there are asv_df_percentages, which contains the normalized counts, and asv_diversity_perSample which contains the measures of clonal heterogeneity;

<<example_msa>>=
revo_msa = perform_msa(revo_analyzed)
@

This step performs multi sequence alignemnt among the filtered ASVs. Alignment is performed using muscle, and users can provide any optional parameter for the algorithm through this function.
After MSA, REvoBC identifies, for each position in the original barcode, the number of alterations found on the different ASVs. The final result is shown in figure gghist_del_sub_ins_perc.pdf which indicates for each position the frequency of the different mutations in each sample.
This computation stores inside the REvoBC object a new field called alignment, which gets populated by 5 new fields: msa_stringset is the output of multiple sequence alignemnt performed by musle; mutations_df is a tibble
where each line corresponds to a nucleotide in each ASV with the corresponding sample in which it was found, and it indicates whether the nucletide is mutated, the type of alteration and the frequency of that mutation in the corresponding sample; asv_alteration_width is another tibble
which stores the number of nucleotides affected by each type of alteration in each ASV; mutations_coordinates contains the details about mutations, with the start and end positions and the corresponding mutated sequence (note that consecutive nucleotides affected by either an insertion or a deletion will be put toghether and considered ad a unique mutation);
binary_mutations_matrix is finally a binary tibble, where each line corresponds to an ASV, and each column corresponds to a mutation. 1 and 0 indicate respectively the presence or absence of the mutation in the ASV.

<<example_phylogeny, eval=FALSE>>=
revo_phyl = infer_phylogeny(revo_msa, phylip_package_path = 'C:/Users/*/Program Files/phylip-3.698/exe/')
@

This step computes the phylogeny, using the binary mutation matrix computed in the previous step. Phylogeny is computed using camin-sokal method, using the implementation found in the package Rphylip.
Note that prior to running this function, users should install PHYLIP and then provide the path to the folder containing the binary of mix using the parameter phylip_package_path.
This functions infers the phylogeny and store the resulting tree inside the field phylogeny of the REvoBC objetc.

<<example_plot_summary, eval=FALSE>>=
summary_figure = plot_summary(revo_phyl)
@

Finally, a summary plot is prodced and stored in the output directory associated to the REvoBC object. This plot is composed by 7 panels: the first contains the tree representation; then, there is a graphical
representation of each ASV, that gives information about the position of all its mutations; next there is a barplot indicating the total number of nucletoides affected by each alteration type in each ASV;
next there is a second barplot indicating the length of each ASV; next we find a bubble plot, which encodes the percentage sequence similarity of each ASV with respect to the original barcode; finally, there is a dot plot
where the size of each dot indicate the frequency of each ASV normalized by the total counts found in the corresponding sample, and the color of the dot represent the count normalized to the highest counts found for the same ASV in another sample.

\section{\Rcode{sessionInfo()}}

<<sessioninfo,results='asis',echo=FALSE>>=
toLatex(sessionInfo())
@

\end{document}
